{"version":3,"sources":["../../src/server.ts","../../src/lib/error-handeling/index.ts","../../src/lib/logger/pino.logger.ts","../../src/lib/logger/index.ts","../../src/app.ts"],"sourcesContent":["import closeWithGrace from \"close-with-grace\";\nimport * as dotenv from \"dotenv\";\nimport Fastify from \"fastify\";\nimport { AppError, errorHandler, normalizeError } from \"@/lib/error-handeling\";\n\nimport { logger } from \"@/lib/logger\";\n\nimport app from \"./app\";\n\ndotenv.config();\n\nconst isProduction = process.env.NODE_ENV === \"production\";\nconst server = Fastify({\n  logger: !isProduction,\n});\n\n// Register your application as a normal plugin.\nvoid server.register(app);\n\n// Delay is the number of milliseconds for the graceful close to finish\nconst closeListeners = closeWithGrace({ delay: 500 }, async (opts: any) => {\n  if (opts.err) {\n    logger.error(`${opts.err.message}, closing app...`);\n  }\n\n  await server.close();\n});\n\nserver.addHook(\"onClose\", (_instance, done) => {\n  closeListeners.uninstall();\n  done();\n});\n\n// Start listening.\nserver.listen(\n  {\n    port: Number(process.env.PORT ?? 4200),\n    host: process.env.SERVER_HOSTNAME ?? \"127.0.0.1\",\n  },\n  (err: Error | null, address: string) => {\n    if (err) {\n      logger.error(`Error listening server: ${err.message}`);\n      process.exit(1);\n    }\n\n    // Here we integrate the error event listener\n    errorHandler.listenToErrorEvents(server.server);\n\n    logger.info(`Server listening at ${address}`);\n  },\n);\n\nserver.ready(async (err: Error) => {\n  if (err) {\n    await errorHandler.handleError(\n      new AppError(\"startup-failure\", err.message, 500, false, err),\n    );\n\n    logger.error(`Error starting server: ${err.message}`);\n    process.exit(1);\n  }\n\n  // server.swagger();\n\n  logger.info(\"All routes loaded! Check your console for the route details.\");\n\n  console.log(server.printRoutes());\n\n  logger.info(`Server listening on port ${Number(process.env.PORT ?? 4200)}`);\n});\n\nserver.setErrorHandler(async (error, request, reply) => {\n  logger.info(JSON.stringify(error));\n  const appError = normalizeError(error);\n  const isValidationError = error.code === \"FST_ERR_VALIDATION\";\n\n  // Assign a default trusted status if not present\n  if (appError.isTrusted === undefined || appError.isTrusted === null) {\n    appError.isTrusted = true; // Error during a specific request is usually not fatal\n  }\n\n  if (isValidationError) {\n    await reply.status(error.statusCode ?? 400).send({\n      name: \"The incoming request format incorrect\",\n      message: error.message || \"The incoming request format incorrect\",\n      code: \"VAL_ERR\",\n    });\n    return;\n  }\n\n  if (!isValidationError) {\n    await reply.status(appError.HTTPStatus || 500).send({\n      name: appError.name,\n      message: appError.message,\n      code: appError.code,\n    });\n  }\n\n  await errorHandler.handleError(appError);\n});\n\nexport { server as app };\n","import type * as Http from \"http\";\nimport * as util from \"util\";\nimport { logger } from \"../logger\";\n\nlet httpServerRef: Http.Server;\n\nconst errorHandler = {\n  // Listen to the global process-level error events\n  listenToErrorEvents(httpServer: Http.Server) {\n    httpServerRef = httpServer;\n    process.on(\"uncaughtException\", async (error) => {\n      await errorHandler.handleError(error);\n    });\n\n    process.on(\"unhandledRejection\", async (reason) => {\n      await errorHandler.handleError(reason);\n    });\n\n    process.on(\"SIGTERM\", async () => {\n      logger.error(\n        \"App received SIGTERM event, try to gracefully close the server\",\n      );\n      await terminateHttpServerAndExit();\n    });\n\n    process.on(\"SIGINT\", async () => {\n      logger.error(\n        \"App received SIGINT event, try to gracefully close the server\",\n      );\n      await terminateHttpServerAndExit();\n    });\n  },\n\n  async handleError(errorToHandle: unknown) {\n    try {\n      const appError: AppError = normalizeError(errorToHandle);\n      logger.error(`AppError: ${appError.message}`);\n      await metricsExporter.fireMetric(\"error\", { errorName: appError.name }); // fire any custom metric when handling error\n      // A common best practice is to crash when an unknown error (non-trusted) is being thrown\n      if (!appError.isTrusted) {\n        await terminateHttpServerAndExit();\n      }\n    } catch (handlingError: unknown) {\n      // Not using the logger here because it might have failed\n      process.stdout.write(\n        \"The error handler failed, here are the handler failure and then the origin error that it tried to handle\",\n      );\n      process.stdout.write(JSON.stringify(handlingError));\n      process.stdout.write(JSON.stringify(errorToHandle));\n    }\n  },\n};\n\nconst terminateHttpServerAndExit = async () => {\n  // maybe implement more complex logic here (like using 'http-terminator' library)\n  if (httpServerRef) {\n    httpServerRef.close();\n  }\n\n  process.exit();\n};\n\n// The input might won't be 'AppError' or even 'Error' instance, the output of this function will be - AppError.\nconst normalizeError = (errorToHandle: unknown): AppError => {\n  if (errorToHandle instanceof AppError) {\n    return errorToHandle;\n  }\n\n  if (errorToHandle instanceof Error) {\n    const appError = new AppError(errorToHandle.name, errorToHandle.message);\n    appError.stack = errorToHandle.stack;\n    return appError;\n  }\n\n  // meaning it could be any type,\n  const inputType = typeof errorToHandle;\n  return new AppError(\n    \"general-error\",\n    `Error Handler received a none error instance with type - ${inputType}, value - ${util.inspect(\n      errorToHandle,\n    )}`,\n  );\n};\n\ntype ERR_CODES = \"VAL_ERR\" | \"ERR_GENERAL\";\n\nclass AppError extends Error {\n  constructor(\n    public name: string,\n    public message: string,\n    public HTTPStatus = 500,\n    public isTrusted = true,\n    public code: ERR_CODES = \"ERR_GENERAL\",\n    public cause?: unknown,\n  ) {\n    super(message);\n  }\n}\n\n// This simulates a typical monitoring solution that allow firing custom metrics when\n// like Prometheus, DataDog, CloudWatch, etc\nconst metricsExporter = {\n  async fireMetric(name: string, labels: Record<string, unknown>) {\n    // TODO: use logger instead of conso.log\n\n    console.log(\"In real production code I will really fire metrics\", {\n      name,\n      labels,\n    });\n  },\n};\n\nexport {\n  errorHandler,\n  metricsExporter,\n  AppError,\n  normalizeError,\n  terminateHttpServerAndExit,\n};\n","import {\n  pino,\n  type Logger as PinoLoggerImpl,\n  type DestinationStream,\n} from \"pino\";\nimport { type LOG_LEVELS, type Logger } from \"./definition\";\n\nexport default class PinoLogger implements Logger {\n  readonly #logger: PinoLoggerImpl;\n\n  constructor(\n    private readonly level: LOG_LEVELS,\n    private readonly prettyPrintEnabled: boolean,\n    private readonly destStream?: DestinationStream | string,\n  ) {\n    this.#logger = pino({\n      level,\n      transport: prettyPrintEnabled\n        ? {\n            target: \"pino-pretty\",\n            options: {\n              colorize: true,\n              sync: true,\n            },\n          }\n        : undefined,\n    });\n  }\n\n  debug(message: string, metadata?: Record<string, unknown>): void {\n    if (metadata) {\n      this.#logger.debug(metadata, message);\n    } else {\n      this.#logger.debug(message);\n    }\n  }\n\n  error(message: string, metadata?: Record<string, unknown>): void {\n    if (metadata) {\n      this.#logger.error(metadata, message);\n    } else {\n      this.#logger.error(message);\n    }\n  }\n\n  info(message: string, metadata?: Record<string, unknown>): void {\n    if (metadata) {\n      this.#logger.info(metadata, message);\n    } else {\n      this.#logger.info(message);\n    }\n  }\n\n  warning(message: string, metadata?: Record<string, unknown>): void {\n    if (metadata) {\n      this.#logger.warn(metadata, message);\n    } else {\n      this.#logger.warn(message);\n    }\n  }\n}\n","import { type Logger, type LoggerConfiguration } from \"./definition\";\nimport PinoLogger from \"./pino.logger\";\nimport { metricsExporter } from \"../error-handeling\";\n\nexport class LoggerWrapper implements Logger {\n  // @ts-expect-error description: 'abcd'\n  #underlyingLogger: Logger | undefined = null;\n\n  configureLogger(\n    configuration: Partial<LoggerConfiguration>,\n    overrideIfExists = true,\n  ): void {\n    if (this.#underlyingLogger === null || overrideIfExists) {\n      this.#underlyingLogger = new PinoLogger(\n        configuration.level ?? \"info\",\n        configuration.prettyPrint ?? false,\n      );\n    }\n  }\n\n  resetLogger() {\n    // @ts-expect-error description: 'abcd'\n    this.#underlyingLogger = null;\n  }\n\n  debug(message: string, metadata?: Record<string, unknown>): void {\n    this.#getInitializeLogger().debug(message);\n  }\n\n  error(message: string, metadata?: Record<string, unknown>): void {\n    this.#getInitializeLogger().error(message);\n  }\n\n  info(message: string, metadata?: Record<string, unknown>): void {\n    // If never initialized, the set default configuration\n    this.#getInitializeLogger().info(message);\n  }\n\n  warning(message: string, metadata?: Record<string, unknown>): void {\n    this.#getInitializeLogger().warning(message);\n  }\n\n  #getInitializeLogger(): Logger {\n    this.configureLogger({ prettyPrint: true }, false);\n\n    return this.#underlyingLogger!;\n  }\n}\n\nexport const logger = new LoggerWrapper();\n","// Require('module-alias/register')\nimport { join } from \"path\";\nimport AutoLoad, { type AutoloadPluginOptions } from \"@fastify/autoload\";\nimport { type FastifyPluginAsync } from \"fastify\";\nimport { TypeBoxValidatorCompiler } from \"@fastify/type-provider-typebox\";\n\nexport type AppOptions = {\n  // Place your custom options for app below here.\n} & Partial<AutoloadPluginOptions>;\n\n// Pass --options via CLI arguments in command to enable these options.\nconst options: AppOptions = {};\n\nconst app: FastifyPluginAsync<AppOptions> = async (\n  fastify,\n  opts,\n): Promise<void> => {\n  // Place here your custom code!\n  void fastify.setValidatorCompiler(TypeBoxValidatorCompiler);\n  // Do not touch the following lines\n\n  // This loads all plugins defined in plugins\n  // those should be support plugins that are reused\n  // through your application\n  void fastify.register(AutoLoad, {\n    dir: join(__dirname, \"plugins\"),\n    options: opts,\n  });\n\n  // This loads all plugins defined in routes\n  // define your routes in one of these\n  void fastify.register(AutoLoad, {\n    dir: join(__dirname, \"./entry-points/http/\"),\n    options: opts,\n  });\n};\n\nexport default app;\nexport { app, options };\n"],"mappings":"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","names":["_a","_b","_a"]}
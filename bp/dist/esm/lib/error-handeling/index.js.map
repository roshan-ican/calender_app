{"version":3,"sources":["../../../../src/lib/error-handeling/index.ts","../../../../src/lib/logger/pino.logger.ts","../../../../src/lib/logger/index.ts"],"sourcesContent":["import type * as Http from \"http\";\nimport * as util from \"util\";\nimport { logger } from \"../logger\";\n\nlet httpServerRef: Http.Server;\n\nconst errorHandler = {\n  // Listen to the global process-level error events\n  listenToErrorEvents(httpServer: Http.Server) {\n    httpServerRef = httpServer;\n    process.on(\"uncaughtException\", async (error) => {\n      await errorHandler.handleError(error);\n    });\n\n    process.on(\"unhandledRejection\", async (reason) => {\n      await errorHandler.handleError(reason);\n    });\n\n    process.on(\"SIGTERM\", async () => {\n      logger.error(\n        \"App received SIGTERM event, try to gracefully close the server\",\n      );\n      await terminateHttpServerAndExit();\n    });\n\n    process.on(\"SIGINT\", async () => {\n      logger.error(\n        \"App received SIGINT event, try to gracefully close the server\",\n      );\n      await terminateHttpServerAndExit();\n    });\n  },\n\n  async handleError(errorToHandle: unknown) {\n    try {\n      const appError: AppError = normalizeError(errorToHandle);\n      logger.error(`AppError: ${appError.message}`);\n      await metricsExporter.fireMetric(\"error\", { errorName: appError.name }); // fire any custom metric when handling error\n      // A common best practice is to crash when an unknown error (non-trusted) is being thrown\n      if (!appError.isTrusted) {\n        await terminateHttpServerAndExit();\n      }\n    } catch (handlingError: unknown) {\n      // Not using the logger here because it might have failed\n      process.stdout.write(\n        \"The error handler failed, here are the handler failure and then the origin error that it tried to handle\",\n      );\n      process.stdout.write(JSON.stringify(handlingError));\n      process.stdout.write(JSON.stringify(errorToHandle));\n    }\n  },\n};\n\nconst terminateHttpServerAndExit = async () => {\n  // maybe implement more complex logic here (like using 'http-terminator' library)\n  if (httpServerRef) {\n    httpServerRef.close();\n  }\n\n  process.exit();\n};\n\n// The input might won't be 'AppError' or even 'Error' instance, the output of this function will be - AppError.\nconst normalizeError = (errorToHandle: unknown): AppError => {\n  if (errorToHandle instanceof AppError) {\n    return errorToHandle;\n  }\n\n  if (errorToHandle instanceof Error) {\n    const appError = new AppError(errorToHandle.name, errorToHandle.message);\n    appError.stack = errorToHandle.stack;\n    return appError;\n  }\n\n  // meaning it could be any type,\n  const inputType = typeof errorToHandle;\n  return new AppError(\n    \"general-error\",\n    `Error Handler received a none error instance with type - ${inputType}, value - ${util.inspect(\n      errorToHandle,\n    )}`,\n  );\n};\n\ntype ERR_CODES = \"VAL_ERR\" | \"ERR_GENERAL\";\n\nclass AppError extends Error {\n  constructor(\n    public name: string,\n    public message: string,\n    public HTTPStatus = 500,\n    public isTrusted = true,\n    public code: ERR_CODES = \"ERR_GENERAL\",\n    public cause?: unknown,\n  ) {\n    super(message);\n  }\n}\n\n// This simulates a typical monitoring solution that allow firing custom metrics when\n// like Prometheus, DataDog, CloudWatch, etc\nconst metricsExporter = {\n  async fireMetric(name: string, labels: Record<string, unknown>) {\n    // TODO: use logger instead of conso.log\n\n    console.log(\"In real production code I will really fire metrics\", {\n      name,\n      labels,\n    });\n  },\n};\n\nexport {\n  errorHandler,\n  metricsExporter,\n  AppError,\n  normalizeError,\n  terminateHttpServerAndExit,\n};\n","import {\n  pino,\n  type Logger as PinoLoggerImpl,\n  type DestinationStream,\n} from \"pino\";\nimport { type LOG_LEVELS, type Logger } from \"./definition\";\n\nexport default class PinoLogger implements Logger {\n  readonly #logger: PinoLoggerImpl;\n\n  constructor(\n    private readonly level: LOG_LEVELS,\n    private readonly prettyPrintEnabled: boolean,\n    private readonly destStream?: DestinationStream | string,\n  ) {\n    this.#logger = pino({\n      level,\n      transport: prettyPrintEnabled\n        ? {\n            target: \"pino-pretty\",\n            options: {\n              colorize: true,\n              sync: true,\n            },\n          }\n        : undefined,\n    });\n  }\n\n  debug(message: string, metadata?: Record<string, unknown>): void {\n    if (metadata) {\n      this.#logger.debug(metadata, message);\n    } else {\n      this.#logger.debug(message);\n    }\n  }\n\n  error(message: string, metadata?: Record<string, unknown>): void {\n    if (metadata) {\n      this.#logger.error(metadata, message);\n    } else {\n      this.#logger.error(message);\n    }\n  }\n\n  info(message: string, metadata?: Record<string, unknown>): void {\n    if (metadata) {\n      this.#logger.info(metadata, message);\n    } else {\n      this.#logger.info(message);\n    }\n  }\n\n  warning(message: string, metadata?: Record<string, unknown>): void {\n    if (metadata) {\n      this.#logger.warn(metadata, message);\n    } else {\n      this.#logger.warn(message);\n    }\n  }\n}\n","import { type Logger, type LoggerConfiguration } from \"./definition\";\nimport PinoLogger from \"./pino.logger\";\nimport { metricsExporter } from \"../error-handeling\";\n\nexport class LoggerWrapper implements Logger {\n  // @ts-expect-error description: 'abcd'\n  #underlyingLogger: Logger | undefined = null;\n\n  configureLogger(\n    configuration: Partial<LoggerConfiguration>,\n    overrideIfExists = true,\n  ): void {\n    if (this.#underlyingLogger === null || overrideIfExists) {\n      this.#underlyingLogger = new PinoLogger(\n        configuration.level ?? \"info\",\n        configuration.prettyPrint ?? false,\n      );\n    }\n  }\n\n  resetLogger() {\n    // @ts-expect-error description: 'abcd'\n    this.#underlyingLogger = null;\n  }\n\n  debug(message: string, metadata?: Record<string, unknown>): void {\n    this.#getInitializeLogger().debug(message);\n  }\n\n  error(message: string, metadata?: Record<string, unknown>): void {\n    this.#getInitializeLogger().error(message);\n  }\n\n  info(message: string, metadata?: Record<string, unknown>): void {\n    // If never initialized, the set default configuration\n    this.#getInitializeLogger().info(message);\n  }\n\n  warning(message: string, metadata?: Record<string, unknown>): void {\n    this.#getInitializeLogger().warning(message);\n  }\n\n  #getInitializeLogger(): Logger {\n    this.configureLogger({ prettyPrint: true }, false);\n\n    return this.#underlyingLogger!;\n  }\n}\n\nexport const logger = new LoggerWrapper();\n"],"mappings":"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","names":[]}